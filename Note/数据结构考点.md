# 数据结构考点总结

## 求二叉树的遍历序列

## 折半查找判定树

## 矩阵的压缩存储

## 二叉排序树

## 汉诺塔

## 二叉线索树

## 求最小生成树

1. 普里姆算法(Prim)
2. 克鲁斯卡尔算法(Kruskal)

## 最短路径

1. Dijkstra(迪杰斯特拉)算法
2. Floyd(弗洛伊德)算法

## 拓扑排序

## 关键路径

## 已知先根和后根序列 求树

## 编写程序

### 2010

1. 将数组中的奇数移到偶数之前
2. 建立二叉树 用二叉链表存储，写交换二叉树左右子树的算法
3. 孩子-兄弟结点结构，写算法由根开始逐层输出树中的各条边

### 2011

1. 建立二叉树 用二叉链表存储，写计算二叉树中度为0度为1的结点数目的算法
2. 输入n个有序数组存入数组，输入关键字key，完成折半查找
3. 二叉树的层次遍历

### 2012

1. 子串 t 在主串 s 中第一次出现的位置指针
2. 建立二叉树 用二叉链表存储，写输出二叉树中的非叶子结点的算法
3. 无向图 邻接表结构存储 实现广度优先搜索策略遍历图中所有顶点

### 2013

1. 子串 t 在主串 s 中第一次出现的位置指针
2. 编写二叉排序树由小到大的结点值递增序列的算法
3. 无向图 邻接表结构存储 实现广度优先搜索策略遍历图中所有顶点
4. 在前序线索树中要找出 X 结点的后继结点

### 2014

1. `void Adjust(LinkList L)`以第一个元素为基准，将小于该元素的结点全部放到前面，大于该元素的结点全部放到其后。  
2. 要求循环队列不损失一个空间全部都能得到利用，设置一个标志域 tag，以tag 为 0 或 1 来区分头尾指针相同时的列状态的空与满，请编写与此结构相应的出队算法。  
3. 二叉树采用二叉链表结构存储，编写算法实现统计二叉树中的结点个数。
4. 二叉树采用二叉链表结构存储，编写实现二叉树后序线索化的算法。
5. 编写算法，由依次输入的顶点数、弧数和各顶点信息、弧信息建立有向图的邻接表存储结构

### 2015

1. 已知带头结点的单链表L,编写一个尽量高效的算法将L中的元素就地逆置
2. 在中序线索树中，编写算法找出X结点的后继结点。
3. 已知二叉树采用二叉链表存储，编写算法，判断其是否为完全二叉树
4. `void CreateHashTable(int ht[],int n)`,其功能是：依次输入n个整数，构造哈希表。哈希函数是除留余数法，处理冲突的方法采用线性探测再散列（假设表长是m,p是小于或等于m的最大质数）

### 2016

1. 某顺序表中的元素为整型，设第一个元素为key。编写尽可能高效的算法
将小于等于key的元素全部放在其前面，大于key的元素全部放在其后面
2. 在二叉排序树中查找关键字为key的结点。若找到，返回该结点的地址：否
则返回NULL
3. 对带头结点的单链表Head进行简单选择排序，排序后结点值从小到大排序
4. 某有向图采用邻接表存储，编写算法输出该图的拓扑序列

### 2017

1. 已知带头结点的单链表L,编写算法删除值最大的结点
2. 二叉树采用二叉链表方式存储，编写算法实现二叉树的层次遍历
3. 一棵二叉树采用二叉链表方式存储，编写算法判断给定的这棵二叉
树是否为二叉排序树
4. 某关键字序列按除留余数法构建了哈希表，H(key)=key%P(P小
于等于m),采用线性探测再散列解决冲突。编写算法，对给定长度为m、
元素个数为n的哈希表（m大于等于n),计算等概率情况下查找成功的
平均查找长度

### 2018

1. 从尾到头打印单链表，要求不改变该链表顺序，算法尽可能高效
2. 利用栈的基本操作，判断给定的字符串是否为回文串
3. 已知树采用孩子-兄弟链存储，编写算法求该树的高度
4. 某二叉树采用二叉链表存储，判断该二叉树是否是完全二叉树
5. 已知一个无向连通图G,采用邻接表存储。求从$V_{i}$出发到$V_{j}$($V_{i}$不等于$V_{j}$,)所经结点数目最少的路径.

### 2019

1. 在一个顺序表L中，编写算法删除所有值介于x和y之间的所有无素
2. 二叉村采用二叉链表存储表示。编写算法求取一棵二叉树的路径长度
3. 循环队列中，不损失单元而是增加一个tag来辅助区分队空和队满，写出在此结构下的出队和入队的操作
4. 某树以孩子——兄弟链存储，编写算法按层次以（双亲、孩子）的形式输出树中所有的边
5. 已知一个无向边连通图G,采用邻接表存储。求从$V_{i}$出发到$V_{j}$($V_{i}$不等于$V_{j}$)所经结点数目最少的路径
