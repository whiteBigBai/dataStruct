# 2020 #

## 一,简答 ##

1. 查找第i个元素及其前驱，使用顺序表,单链表,单向循环链表,双向循环链表哪个更高效,并说明理由.

    >顺序表更高效,因为顺序表可以根据下标查找元素,其他的都需要进行遍历

2. 如何判断有向图中是否存在环（回路）,简述方法思路.

    >对有向图进行拓扑排序,若有向图的顶点不能排在一个拓扑序列中,则可判定该有向图存在回路。

3. 简单选择排序的性能(从元素关键字的比较次数，移动次数分析)以及稳定性.

    >元素的比较次数与序列的初始状态无关,始终都是$n\times(n-1)\div2$次，因此时间复杂度始终为$O(n^2)$  
    >元素的移动次数很少,不会超过$3(n-1)$次
    >只需要常数个辅助单元，所以空间复杂度为O(1).  
    >稳定性:不稳定

4. 简述算法特性.

   >算法是规则的有限集合，是为解决特定问题而规定的一系列操作。
   >有限性,确定性,可行性,输入,输出。

## 二,分析 ##

1. 分析以下程序段中,语句`s++`的语句频度及算法时间复杂度.

    ```c
        for(i=0,s=0;i<=n;i++){
            for(j=0;j<=i;j++){
                for(k=0;k<=j;k++){
                    s++;
                }
            }
        }            
    ```

    >基本语句`s++`的执行次数为$T(n)=O(\sum_{i=0}^n \sum_{j=0}^i \sum_{k=0}^j  1)=O(1/6 *n^3)=O(n^3)$

2. 写出`fun(1234)`的调用过程及调用结果.

    ```c
        void fun(int n){
            printf("%d",n%10);
            if(n/10!=0){
                fun(n/10);
            }
        }
    ```

    >
    ```c
    fun(1234)
        printf(4);
        fun(123);
            printf(3);
            fun(12);
                printf(2);
                fun(1);
                    printf(1);
    ```

3. 完全二叉树中,第7层有8个叶子结点，分析并求出该完全二叉树中结点总数.

    >前6层有$2^6-1=63$个节点  
    >共$63+8=71$个节点

## 三,构造 ##

1. 上三角矩阵$A_{n \times n}$(从$A_{11}$开始)存放在一维数组`B[1,2,...,m]`。(采用行序为主的压缩存储)。

    (1) 求m的值  
    (2) 用i,j表示k的下标变换公式。

2. 若二叉树采用二叉链表存储,请写出在后序线索树中找节点P的直接前驱节点和线序线索树中找节点P的直接后继节点的操作。
3. 一组关键字`{7,8,30,11,18,9,14}`,哈希函数`H(key)=(key*3)%7`,装填因子为`0.7`,采用线性探测再散列处理冲突.

    (1) 构造哈希表  
    (2) 计算等概率情况下查找成功与失败的平均查找长度

4. 给出连通网。

    (1) 写出邻接矩阵  
    (2) 用克鲁斯卡尔算法求该连通图最小生成树的过程及结果。

5. 待排序序列{42,30,35,92,100,96,88,110}，写出一第一个元素为枢轴进行快速排序的过程。

## 四,编写算法 ##

1. 设线性表C={$a_{1},b_{1},a_{2},b_{2},...,a_{n},b_{n}$}，采用带头节点的单链表存放，设计一个算法，将其拆分为两个线性表，使得A={$a_{1},a_{2},...,a_{n}$}，B={$b_{1},b_{2},...,b_{n}$}

    ```c
    LinkList DisCreat(LinkList &A)
    {
        i = 0;
        B = (LinkList)malloc(sizeof(LNode));
        B->next = NULL;
        LNode *ra = A, *rb = B;

        p = A->next;
        A->next = NULL;
        while (p != NULL)
        {
            i++;
            if (i % 2 == 0)
            {
                rb->next = p;
                rb = p;
            }
            else
            {
                ra->next = p;
                ra = p;
            }
            p = p->next;
        }
        ra->next = NULL;
        rb->next = NULL;
        return B;
    }
    ```

2. 二叉树用二叉链表存储，编写算法，找出二叉树中最大值节点并返回。

   ```c
    void getMax(BiTree T)
    {
        LinkQueue Q;
        InitQueue(Q); //初始化辅助队列
        BiTNode *p = (BiTNode *)malloc(sizeof(BiTNode));
        EnQueue(Q, T); //将根结点入队
        int max=0;
        while (!IsEmpty(Q))
        {                  //队列不空则循环
            DeQueue(Q, p); //队头结点出队
            if(p->data>max){
                max=p->data;
            }
            if (p->lchild != NULL)
                EnQueue(Q, p->lchild); //左孩子入队
            if (p->rchild != NULL)
                EnQueue(Q, p->rchild); //右孩子入队
        }
        printf("%d ", max);
    }
   ```

3. 树采用孩子-兄弟法表示,找出值为x的节点，删除以它为根的子树。

## 五,编写算法 ##

1. 编写算法，由依次输入的顶点数,弧数和各顶点信息,弧信息建立有向图的邻接表存储结构。

## 六,编写算法 ##
