# 2013

## 一、简答问题

1、线性结构与非线性结构的差别。

>线性结构中结点间具有唯一前驱、唯一后继关系，而非线
>性结构中结点间前驱、后继的关系并不具有唯一性

2、说明在图的遍历中，设置访问标志数组的作用。

>为了保证图中的各顶点在遍历过程中访问且仅访问一次，
>需要为每个顶点设一个访问标志，因此要为图中设置一个
>访问标志数组，用于标志图中每个顶点是否被访问过。

3、简述数组和字符串属于线性表的原因。

>(数组是一种扩展的线性数据结构.其特殊性反映在数据元素的构成上，其数据元素可以是单个元素也可以是一个线性结构）对于一维数组而言具有唯一前驱和唯一后继，而二维数组可以定义为数据元素为一维数组（线性表）的线性表。
>串是由零个或多个字符组成的有限序到，其前驱和后继唯一，因此串也是一种特定的线性表，串的逻辑结构和线性表极为相似，其特定性仅在于串的数据对象限定为字符集。

4、算法特性与算法时间复杂度。

>（1）有限性（2）确定性（3）可行性（4）有多个或0个输入（5）至少一个或多个输出
>算法的时间复杂度T(n)是该算法的时间度量，记作.
>T(n)=O(f(n))
>它表示随问题规模n的增大，算法的执行时间的增长率
>和f(n)的增长率相同，称作算法的渐近时间复杂度，
>简称时间复杂度。

5、数据类型与抽象数据类型。

> 数据类型是一组性质相同的值集合以及定义在这个值集合上的一组操作的总称。
>
> 抽象数据类型定义了一个数据对象、数据对象中各元素间的关系以及一组处理数据的操作。

6、简述稳定排序含义，给出一种不稳定排序方法名称并证明。

   >假设在待排序的序列中存在多个相同关键字的记录。设$K_{i}$=$K_{j}$($1<=i<=n,1<=j<=n,i!=j$),
   >若在排序前的序列中$R_{i}$领先于$R_{j}$(即$i<j$),经过排序后得到的序列中$R_{i}$仍领先于$R_{j}$,则称所用的排序方法是稳定的。
   >不稳定的排序举例:希尔排序`{2,4,1,2*}` 快速排序`{3,3*,2}`
   >堆排序`{5,5*,3}`

## 二、方法选择

1、设有 10000 个无序元素，要求找出前 30 个最大元素，在下列排序方法（归并
排序、基数排序、快速排序、堆排序、插入排序）中哪些方法最好，为什么？

>堆排序，因为堆排序一趟排序就可以排定一个元素，只需
>要进行前30趟排序就可以了，而其他方法需要完全排序。O($n\log_{2}n$)

2、在一个待排序的序列中，只有很少量元素不在自己最终的正确位置上，但离
他们的正确位置都不远，简述应使用哪种排序方法最好。

> 直接插入排序，算法简便，适用于待排序记录数目较少且基本有序的情况。

## 三、构造结果

1、给定叶结点权值：（3，4，5，6，7，8，9），构造哈夫曼树，并计算其带权路
径长度。

>3.1.gv
>`WPL=(3+4)*4+(5+6+7)*3+(8+9)*2=28+54+34=116`

2、已知一二叉树中序序列为 BDCAEF，前序序列为 ABCDEF，给出其对应的二叉树。

>3.2.gv

3、已知二维数组 A[100][200]采用行序为主方式存储，每个元素占 K 个存储单
元，已知 A[0][0]的存储地址是 1500，给出 A[60][80]的存储地址。

>`LOC(A[60][80])=LOC(A[0][0])+(60*200+80)*K`

4、给出 12 个结点的折半判定树，并计算其在等概率情况下的平均查找长度。

>3.4.gv
>`ASL=(5*4+4*3+2*2+1)/12=37/12`

5、在地址空间 0—12 的散列区中，对以下关键字序列：（Jan，Feb，Apr，May，
Jun，Jul，Aug，Sep，Oct）建哈希表，设哈希函数为 H(X)=i/2，其中 i 为关键
字中的第一个字母在字母表中的序号，处理冲突可选用线性探测法或链地址法之
一，要求构造哈希表，并求出在等概率的情况下查找成功与不成功的平均查找长
度。
| 散列区       | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   |
| ------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 关键字       | Apr  | Aug  |      | Feb  |      | Jan  | May  | Jun  | Jul  | Sep  | Oct  |      |      |      |
| 成功比较次数 | 1    | 2    |      | 1    |      | 1    | 1    | 3    | 4    | 1    | 4    |      |      |      |
| 失败比较次数 | 3    | 2    | 1    | 2    | 1    | 7    | 6    | 5    | 4    | 3    | 2    | 1    | 1    | 1    |

>ASL(成功)=(1+2+1+1+1+3+4+1+4)/9=2
>
>ASL(不成功)=(3+2+1+2+1+7+6+5+4+3+2+1+1+1)/14=39/14

## 四、编写算法

设主串 s 和子串 t 分别以单链表存储，t 和 s 中的每个字符均用一结点表示
（如图）。

![4.1](4.1.png)

实现在链式存储方式下的模式匹配，即求子串 t 在主串 s 中第一次出现的位
置指针。

## 五、编写算法

已知二叉排序树按二叉链表形式存储，树中结点各不相同，欲得到一个由小
到大的结点值递增序列，编写算法达到要求结果。

   ```c
    void InOrderTraverse(BiTree T)
    {
        if (T)
        {
            InOrderTraverse(T->lchild);
            printf(T->data);
            InOrderTraverse(T->rchild);
        }
    }
   ```

## 六、编写算法

无向图采用邻接表方式存储，编写出广度优先遍历访问的算法。

   ```c
    
   ```

## 七、编写语句

在前序线索树中要找出 X 结点的后继结点。

![7.1](7.1.png)

```c
    ThreadNode *PreNode(ThreadNode *p){
        ThreadNode *pre;
        if(p->Ltag==0){
            pre=p->Lchild;
        }
        else{
            pre= p->Rchild;
        } 
        return pre;
    }
```
